<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring WebFlux 入门系列（二）：事件驱动架构</title>
      <link href="archives/512a6ef2.html"/>
      <url>archives/512a6ef2.html</url>
      
        <content type="html"><![CDATA[<h2 id="请求响应驱动架构"><a href="#请求响应驱动架构" class="headerlink" title="请求响应驱动架构"></a>请求响应驱动架构</h2><p>我们现在大多数服务架构都是<strong>请求响应驱动架构（Request/Response Driven Architecture）</strong>，也就是发一次请求，得到一个结果。一般请求发起方是用户操作，例如查看、修改和保存数据等。但也有些不适用于该架构的场景，例如以下几个场景，你会怎么设计呢？</p><ul><li>实时显示最新数据排行</li><li>实时显示点赞数、转发数</li><li>实时更新任务状态</li></ul><h2 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h2><p><strong>事件驱动架构 （Event Driven Architecture）</strong>由事件发起者和事件订阅者组成。事件的发起者会检测或感知事件，并以消息的形式来表示事件。事件的发起者并不知道事件的订阅者或事件引起的结果，而事件的订阅者也不知道事件的发起者，只是将该消息进行预先定义好的逻辑执行。这里就将发起者和订阅者解耦了。用事件驱动架构来实现上述场景非常简单。</p><ul><li>当数据排行发生变化时，产生一个事件告知所有订阅者最新排行情况。</li><li>当点赞数或转发数发生变化时，产生一个事件告知所有订阅者。</li><li>当任务状态发生变化时，产生一个事件将最新任务状态发送给所有订阅者。</li></ul><p>拿点赞来说，请求发起方由用户变为了数据本身（数据库），当用户点赞时，实际上的执行逻辑大致应该是这样。</p><ol><li>用户点击点赞按钮，向后端发送点赞请求，后端将点赞数 + 1 后写入数据库。</li><li>数据库检测到点赞数发生改变，通知所有建立相关事件的 UI 进行更新。</li></ol><p>如果以事件驱动架构实现动态显示点赞数，那用户所看到的将会是一个不停变化的、互动性极高的程序。例如，突然出现一条点赞数或转发数短时间内增长极快的内容（热搜），比起一条点赞数很高但不会变化的数字来说，这更容易引起用户的兴趣。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>在不同的架构中，对于如何捕获鼠标点击事件是大不相同的。</p><ul><li><p>在请求响应驱动架构中，一般采用轮训方法，那该方式有以下几个缺点。</p><ul><li>CPU 资源浪费</li><li>实时性差</li><li>每个事件（点击、双击、右键）可能需要额外的线程</li></ul></li><li><p>在事件驱动架构中，我们通过监听 onClick 事件来捕获鼠标点击事件，好处如下。</p><ul><li>可忽略不计的资源浪费，收到点击事件直接处理即可。</li><li>实时性非常高。</li><li>不同事件通过监听不同方法即可。</li><li>一般只需要一个主线程和固定大小的线程池（与 CPU 一致）。</li><li>异步非阻塞。</li></ul></li></ul><h2 id="事件驱动架构工作原理"><a href="#事件驱动架构工作原理" class="headerlink" title="事件驱动架构工作原理"></a>事件驱动架构工作原理</h2><ul><li>单线程：在程序中，只有一个主线程在执行程序代码。</li><li>事件队列：在主线程之外，还维护了一个<strong>事件队列（Event Queue）</strong>，当用户的网路请求或其他异步操作到来时，由主线程将其放入事件队列中，此时并不会立即执行它，代码也不会被阻塞，主线程继续执行其他代码。</li><li>事件循环：事件队列由谁来消费呢？那就是<strong>事件循环（Event Pool）</strong>机制了，它会从事件队列中取出一个事件，然后从固定的线程池中取出一个线程去执行，执行完后会通知主线程，主线程执行回调，线程归还线程池，如此循环。</li></ul><p>我们要做的是保证主线程不执行可能导致阻塞的代码，这些代码应该交给事件队列，由事件循环机制调动线程池处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于一些要求实时性高的数据，事件驱动架构能够更完美的胜任，而调用频率不高且不需要实时或动态刷新的数据，我们一般还是建议采用请求响应驱动架构实现，并不是说事件驱动架构就一定好，具体使用时还是要看具体的场景，以场景为主。</p>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tags </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring WebFlux 入门系列（一）：响应式编程</title>
      <link href="archives/1b0037d2.html"/>
      <url>archives/1b0037d2.html</url>
      
        <content type="html"><![CDATA[<h2 id="命令式编程与声明式编程"><a href="#命令式编程与声明式编程" class="headerlink" title="命令式编程与声明式编程"></a>命令式编程与声明式编程</h2><p>在介绍响应式编程之前，我们先简单了解下<strong>命令式编程（Imperative Programming）</strong>与<strong>声明式编程（Declarative Programming）</strong>。我们现在写的代码大多都是命令式编程，也就是说一步一步告诉机器怎么做，而声明式编程是告诉程序我期望一个什么样的结果，而不关心具体是怎么实现的。</p><p><em>代码示例-1</em></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 命令式编程</span><span class="token keyword">boolean</span> contaion <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dataArr <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> data <span class="token operator">:</span> dataArr<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        contaion <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>contaion<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 声明式编程</span>contaion <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>dataArr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span>data <span class="token operator">-</span><span class="token operator">></span> ArrayUtils<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>contaion<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="什么是响应式编程？"><a href="#什么是响应式编程？" class="headerlink" title="什么是响应式编程？"></a>什么是响应式编程？</h2><p><strong>简单来说，响应式编程（Reactive Programming）就是面向数据流编程</strong>。鼠标点击或者键盘按下本质上就是事件流，你可以监听并处理这些事件。这其中有三个核心概念 <strong>Publisher</strong>、<strong>Subscriber</strong> 和 <strong>Stream</strong>，鼠标和键盘是 <strong>Publisher</strong>，监听事件的函数是 <strong>Subscriber</strong>，而点击或按下之后产生的事件即为 <strong>Stream</strong>，其实就是 <a href="https://en.wikipedia.org/wiki/Observer_pattern">Observer Design Pattern</a>。既然和观察者模式一样，那为什么要有响应式编程这个概念呢？我们留到后面介绍。</p><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p><strong>数据流（Stream）</strong> 就是一个按时间排序的事件序列，它可以发出三种信号，<strong>值（Value）</strong>信号、<strong>异常（Error）</strong>信号或<strong>完成（Completed）</strong>信号，在 <code>Spring WebFlux</code> 中，这些信号被扩展，增加了 <strong>请求（Request）</strong>信号、<strong>终止（Terminate）信号</strong>等。我们所要做的就是对需要处理的信号定义相应的事件处理函数。在此基础上，你还可以通过官方提供的组合、过滤和创建等函数去操作这些 Stream。几乎任何东西都可以称之为 Stream：用户输入、时间日期、变量等等。</p><h2 id="变化传递"><a href="#变化传递" class="headerlink" title="变化传递"></a>变化传递</h2><p>上面说到响应式编程模型和观察者模式很像，但又有上面不同呢？那就是<strong>变化传递（Propagation Of Change）</strong>了，在观察者模式中，订阅者收到事件并处理后，这个过程就结束了。但响应式编程不同，它可以将这一次事件处理结果进行传递，就好比流水线作业一样，每个作业总是以上一个作业的结果作为输入，将自身的输出作为下一个作业的输入，直到结束。下面给出了命令式与响应式编程在变量更改时所做出的反应。</p><p><em>代码示例-2</em></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 命令式编程</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> sum <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 响应式编程，这里给出伪代码</span>A <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>B <span class="token operator">:</span><span class="token operator">=</span> A <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 定义一种关系，这里是指 B 永远等于 A + 5</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// B = 6</span>A <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// A 改变</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// B = 8</span></code></pre><p>在命令式编程方式中，<code>sum = a + 5</code> 解释为将 <code>a</code> 的值加 <code>5</code> 再赋值给 <code>sum</code>，这个过程是一次性的，赋值之后 sum 和 <code>a</code> 就没关系了，也就是说 <code>a</code> 的改变是不会传递的。但在响应式编程中，这种变化是可以传递的。在 Excel 中，相信你已经见过不少类似的情况了。</p><h2 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h2><p>熟悉了上面的一些概念之后，我们给出响应式编程的正式概念，<strong>响应式编程是一种面向数据流和变化传递的声明式编程</strong>。这意味着可以在编程语言中很方便地表达静态（数组和列表等）或动态（事件发射器）的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。我们用一张图来更好的解释它。</p><p><img src="../static/202010/0.png"></p><p>如上图，要解释响应式编程可以将其拆开分析</p><ul><li>数据流：图中原型及方形图标</li><li>变化传递：从白色、灰色到红色，从圆型到方形</li><li>声明式编程：图中只给出“我要什么”，而并没有告诉其“我要你怎么做”。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>所以，如果要掌握响应式编程，首先我们先要将编程思维从命令式过渡到声明式，其次，我们所关注的重点，也将从对象或过程转变为数据流和变化传递。当然，还有一个需要关注的点，那就是数据流的来源。数据的变化、走向和最终的结果我们是已知且定义好的，但数据应该由谁来发出呢？它又从哪来呢？我们将在下一篇文章介绍。</p>]]></content>
      
      
      <categories>
          
          <category> 响应式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring WebFlux </tag>
            
            <tag> Reactor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Kubernetes 实现蓝绿发布</title>
      <link href="archives/213ace22.html"/>
      <url>archives/213ace22.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>软件世界比以往任何时候都更快。为了保持竞争力，需要尽快推出新的软件版本，而不会中断活跃用户访问，影响用户体验。越来越多企业已将其应用迁移到 Kubernetes。</p><p>在 Kubernetes 中有几种不同的方式发布应用，所以为了让应用在升级期间依然平稳提供服务，选择一个正确的发布策略就非常重要了，本篇文章将讲解在 Kubernetes 使用蓝绿更新的方式更新镜像。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>蓝绿发布是版本 1 与版本 2 会同时存在，通过控制 Service 来决定使用具体哪一个版本，也称为红黑部署。蓝绿发布与滚动更新不同，版本 2 （<code>绿</code>） 与版本 1（<code>蓝</code>）一起部署，在测试新版本满足要求后，然后更新 Service 对象，通过替换 label selector 中的版本标签来将流量发送到新版本，更新过程如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/15.png"></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="使用-Kubernetes-原生方式升级应用"><a href="#使用-Kubernetes-原生方式升级应用" class="headerlink" title="使用 Kubernetes 原生方式升级应用"></a>使用 Kubernetes 原生方式升级应用</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>image</p><pre><code>bebullish/demo:v1bebullish/demo:v2</code></pre><p>deployment-v1</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> demo<span class="token punctuation">-</span>dp<span class="token punctuation">-</span>v1<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> demo      <span class="token key atrule">version</span><span class="token punctuation">:</span> v1  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> demo        <span class="token key atrule">version</span><span class="token punctuation">:</span> v1    <span class="token key atrule">spec</span><span class="token punctuation">:</span>       <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> demo        <span class="token key atrule">image</span><span class="token punctuation">:</span> bebullish/demo<span class="token punctuation">:</span>v1        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span></code></pre><p>deployment-v2</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> demo<span class="token punctuation">-</span>dp<span class="token punctuation">-</span>v2<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> demo      <span class="token key atrule">version</span><span class="token punctuation">:</span> v2  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> demo        <span class="token key atrule">version</span><span class="token punctuation">:</span> v2    <span class="token key atrule">spec</span><span class="token punctuation">:</span>       <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> demo        <span class="token key atrule">image</span><span class="token punctuation">:</span> bebullish/demo<span class="token punctuation">:</span>v2        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span></code></pre><p>service</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> demo<span class="token punctuation">-</span>service<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> demo    <span class="token key atrule">version</span><span class="token punctuation">:</span> v1                              <span class="token comment" spellcheck="true"># 通过更改 version 来控制流量走向</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> LoadBalancer  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP</code></pre><p>将上述  <code>deployment-v1</code> 以及 <code>service</code> 保存为 yaml 文件，使用 <code>kubectl apply -f</code> 命令创建 yaml 资源，等待创建成功后，使用 <code>kubectl get svc</code> 获取 EXTERNAL-IP。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>如果使用浏览器测试的话，你会发现每次调用都会返回同一个 pod 的名字，那是因为浏览器发出的请求包含 keepAlive，所以需要使用 curl 来保证每次发出的请求都是重新创建的。</p><pre class=" language-sh"><code class="language-sh">curl -X GET http://$&#123;EXTERNAL-IP&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/16.png"></p><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>将上述 <code>deployment-v2</code> 保存为 yaml 文件，使用 <code>kubectl apply -f</code> 命令创建 yaml 资源，切换流量之前先执行命令，以便查看镜像更新过程</p><pre class=" language-sh"><code class="language-sh">while true; do curl -X GET http://$&#123;EXTERNAL-IP&#125; ; done</code></pre><p>等待 <code>deployment-v2</code> 创建成功后，通过将 service 的 version 值改为 v2 来切换流量</p><pre class=" language-sh"><code class="language-sh">kubectl edit service demo-service</code></pre><h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/17.png"></p><h4 id="请求流量"><a href="#请求流量" class="headerlink" title="请求流量"></a>请求流量</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/18.png"></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>首先可以发现在更新过程中，程序保持一直可用的状态，v2 版本部署成功之后，所有请求还是 v1 版本，当流量切换后，立刻出现 v2 版本的日志，并且不会出现 v1 版本的日志，说明流量是一次性切换的，如果需要回滚只需要将流量切回 v1 版本即可。</p><h3 id="使用-CODING-CD-方式升级应用"><a href="#使用-CODING-CD-方式升级应用" class="headerlink" title="使用 CODING CD 方式升级应用"></a>使用 CODING CD 方式升级应用</h3><h4 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/19.png"></p><p>service</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> demo<span class="token punctuation">-</span>service<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">createBy</span><span class="token punctuation">:</span> demo<span class="token punctuation">-</span>service       <span class="token comment" spellcheck="true"># 这里填写的标签，会被添加到对应的 ReplicaSet 中</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> LoadBalancer  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP</code></pre><p>这里注意，service 创建之后应不会匹配到任何资源，即 endpoint 为空，而在后面执行部署流程时会为 ReplicaSet 添加 label <code>createBy: demo-service</code> ，从而决定流量走向。</p><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/20.png"></p><p>部署成功之后可以看到 <code>demo-service</code></p><h4 id="配置制品"><a href="#配置制品" class="headerlink" title="配置制品"></a>配置制品</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/21.png"></p><p>使用 docker 官方镜像需要以 <code>docker.io</code> 开头</p><h4 id="配置-yaml-及绑定制品"><a href="#配置-yaml-及绑定制品" class="headerlink" title="配置 yaml 及绑定制品"></a>配置 yaml 及绑定制品</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/22.png"></p><p>replicaSet</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ReplicaSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> demo<span class="token punctuation">-</span>rs<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> demo  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> demo    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> docker.io/bebullish/demo          <span class="token key atrule">name</span><span class="token punctuation">:</span> demo          <span class="token key atrule">ports</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span></code></pre><p>阶段中选择 <code>部署（Manifest）</code> ，输入上述 yaml 文件（目前发布策略选项仅支持 ReplicaSet），这里需要把镜像的版本删除掉，在需要绑定的制品选择之前配置的制品。这样配置之后，每次执行的时候版本是动态传入的。</p><h4 id="蓝绿（红黑）发布配置"><a href="#蓝绿（红黑）发布配置" class="headerlink" title="蓝绿（红黑）发布配置"></a>蓝绿（红黑）发布配置</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/23.png"></p><p>在下方勾选让 CODING 部署控制台管理入口流量，然后选择 <code>demo-service</code> 所在的命名空间（我这里是在 <code>marlon</code> 这个命名空间下），然后选择 <code>demo-service</code> ，策略选择 Red/Black（Blue/Green），保存即可。</p><h4 id="发布制品"><a href="#发布制品" class="headerlink" title="发布制品"></a>发布制品</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/24.png"></p><p>选择应用和部署流程，输入版本 v1。</p><h4 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/25.png"></p><p>等待一小段时间后，就可以在部署控制台中看到发布的资源了。</p><h4 id="更新镜像版本"><a href="#更新镜像版本" class="headerlink" title="更新镜像版本"></a>更新镜像版本</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/26.png"></p><p>再次执行发布，版本输入 v2。</p><h4 id="更新原理"><a href="#更新原理" class="headerlink" title="更新原理"></a>更新原理</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/27.png"></p><p>基于 CODING CD 的蓝绿发布和一般的蓝绿发布略有不同，一旦 v2 版本的 pod 处于就绪状态后，他就会立即获得流量，而当所有的 v2 版本的 pod 处于就绪状态后，会禁用 v1 版本的 pod，此时所有流量会打到 v2 版本上，从而完成更新。</p><blockquote><p>注意：基于 CODING CD 的蓝绿发布会出现 v1 版本和 v2 版本同时获得流量的情况，具体取决于 pod 的就绪探针，v2 版本的 pod 一旦就绪，那么它就会获得流量，所以需要合理设计就绪探针，尽量减少 v1 版本和 v2 版本同时存在的时间差。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 Kubernetes 原生方式实现蓝绿更新步骤较多，但也容易出错，推荐使用 <a href="https://coding.net/">coding.net</a> 提供的 CD 功能，配置一次，永久使用。不仅降低了人工成本，提高容错率，还提供了非常丰富的 CD 功能，推荐使用哦~</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://spinnaker.io/guides/user/kubernetes-v2/traffic-management/">TrafficManagement</a></p><p><a href="https://spinnaker.io/guides/user/kubernetes-v2/rollout-strategies/">RolloutStrategies</a></p><p><a href="https://help.coding.net/docs/cd/overview.html">CODING 持续部署</a></p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CODING </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> 服务发布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Kubernetes 实现滚动发布</title>
      <link href="archives/17e0ecae.html"/>
      <url>archives/17e0ecae.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>软件世界比以往任何时候都更快。为了保持竞争力，需要尽快推出新的软件版本，而不会中断活跃用户访问，影响用户体验。越来越多企业已将其应用迁移到 Kubernetes。</p><p>在 Kubernetes 中有几种不同的方式发布应用，所以为了让应用在升级期间依然平稳提供服务，选择一个正确的发布策略就非常重要了，本篇文章将讲解如何在 Kubernetes 使用滚动更新的方式更新镜像。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>策略定义为 RollingUpdate 的 Deployment。滚动更新通过逐个替换实例来逐步部署新版本的应用，直到所有实例都被替换完成为止，会有新版旧版同时存在的情况。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">4</span>  <span class="token key atrule">strategy</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> RollingUpdate    <span class="token key atrule">rollingUpdate</span><span class="token punctuation">:</span>      <span class="token key atrule">maxSurge</span><span class="token punctuation">:</span> <span class="token number">0                          </span><span class="token comment" spellcheck="true"># 决定了配置中期望的副本数之外，最多允许超出的 pod 实例的数量</span>      <span class="token key atrule">maxUnavailable</span><span class="token punctuation">:</span> %25            <span class="token comment" spellcheck="true"># 决定了在滚动升级期间，相对于期望副本数能够允许有多少 pod 实例处于不可用状态</span></code></pre><p>上述更新策略执行结果如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/1.png"></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="使用-Kubernetes-原生方式升级应用"><a href="#使用-Kubernetes-原生方式升级应用" class="headerlink" title="使用 Kubernetes 原生方式升级应用"></a>使用 Kubernetes 原生方式升级应用</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>image</p><pre><code>bebullish/demo:v1bebullish/demo:v2</code></pre><p>deployment</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> demo<span class="token punctuation">-</span>dp<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> demo  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">strategy</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> RollingUpdate    <span class="token key atrule">rollingUpdate</span><span class="token punctuation">:</span>      <span class="token key atrule">maxSurge</span><span class="token punctuation">:</span> 25%      <span class="token key atrule">maxUnavailable</span><span class="token punctuation">:</span> 25%  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> demo    <span class="token key atrule">spec</span><span class="token punctuation">:</span>       <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> demo        <span class="token key atrule">image</span><span class="token punctuation">:</span> bebullish/demo<span class="token punctuation">:</span>v1        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span></code></pre><p>service</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> demo<span class="token punctuation">-</span>service<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> demo  <span class="token key atrule">type</span><span class="token punctuation">:</span> LoadBalancer  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP</code></pre><p>将上述 <code>deployment</code> 以及 <code>service</code> 保存为 yaml 文件，使用 <code>kubectl apply -f</code> 命令创建 yaml 资源，等待创建成功后，使用 <code>kubectl get svc</code> 获取 EXTERNAL-IP。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>如果使用浏览器测试的话，你会发现每次调用都会返回同一个 pod 的名字，那是因为浏览器发出的请求包含 keepAlive，所以需要使用 curl 来保证每次发出的请求都是重新创建的。</p><pre class=" language-sh"><code class="language-sh">curl -X GET http://$&#123;EXTERNAL-IP&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/2.png"></p><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>升级之前先执行命令，以便查看镜像更新过程</p><pre class=" language-sh"><code class="language-sh">while true; do curl -X GET http://$&#123;EXTERNAL-IP&#125; ; done</code></pre><p>更新镜像</p><pre class=" language-sh"><code class="language-sh">kubectl set image deployment demo-dp demo=bebullish/demo:v2</code></pre><h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/3.png"></p><h4 id="请求流量"><a href="#请求流量" class="headerlink" title="请求流量"></a>请求流量</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/4.png"></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>首先可以发现在更新过程中，程序保持一直可用的状态，在出现了 v2 版本之后，还会出现 v1 版本的日志，说明在这个期间 v1 和 v2 版本是同时存在的，等到 v2 版本的 pod 全部处于就绪状态之后，可以看到所有的请求就都是 v2 版本的了。</p><h3 id="使用-CODING-CD-方式升级应用"><a href="#使用-CODING-CD-方式升级应用" class="headerlink" title="使用 CODING CD 方式升级应用"></a>使用 CODING CD 方式升级应用</h3><h4 id="配置制品"><a href="#配置制品" class="headerlink" title="配置制品"></a>配置制品</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/5.png"></p><p>使用 docker 官方镜像需要以 <code>docker.io</code> 开头</p><h4 id="配置-yaml-及绑定制品"><a href="#配置-yaml-及绑定制品" class="headerlink" title="配置 yaml 及绑定制品"></a>配置 yaml 及绑定制品</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/6.png"></p><p>deployment</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> demo<span class="token punctuation">-</span>dp<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> demo  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">strategy</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> RollingUpdate    <span class="token key atrule">rollingUpdate</span><span class="token punctuation">:</span>      <span class="token key atrule">maxSurge</span><span class="token punctuation">:</span> 25%      <span class="token key atrule">maxUnavailable</span><span class="token punctuation">:</span> 25%  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> demo    <span class="token key atrule">spec</span><span class="token punctuation">:</span>       <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> demo        <span class="token key atrule">image</span><span class="token punctuation">:</span> docker.io/bebullish/demo        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>        <span class="token key atrule">readinessProbe</span><span class="token punctuation">:</span>          <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /            <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>          <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">30           </span><span class="token comment" spellcheck="true"># 延迟 30 秒检测，以便更好的观察更新过程</span>          <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>        <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>          <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /            <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>          <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">30           </span><span class="token comment" spellcheck="true"># 延迟 30 秒检测，以便更好的观察更新过程</span>          <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>      <span class="token key atrule">terminationGracePeriodSeconds</span><span class="token punctuation">:</span> <span class="token number">1      </span><span class="token comment" spellcheck="true"># 处于 Terminating 状态多久后，强制杀死 pod</span></code></pre><p>阶段中选择 <code>部署（Manifest）</code> ，输入上述 yaml 文件（主要增加了就绪探针和存活探针），这里需要把镜像的版本删除掉，在需要绑定的制品选择之前配置的制品。这样配置之后，每次执行的时候版本是动态传入的。</p><h4 id="发布制品"><a href="#发布制品" class="headerlink" title="发布制品"></a>发布制品</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/7.png"></p><p>选择应用和部署流程，输入版本 v1。</p><h4 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/8.png"></p><p>等待一小段时间后，就可以在部署控制台中看到发布的资源了。</p><h4 id="更新镜像版本"><a href="#更新镜像版本" class="headerlink" title="更新镜像版本"></a>更新镜像版本</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/9.png"></p><p>再次执行发布，版本输入 v2。</p><h4 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/10.png"></p><p>可以看到此时 v2 版本的 pod 有一个正在启动，而 v1 版本的 pod 全部处于就绪状态。</p><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/11.png"></p><p>v2 版本的 pod 有一个已经就绪，同时正在启动另一个新的 pod，与此同时 v1 版本的有一个 pod 已经关机了，而另外两个 pod 仍处于就绪状态。</p><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/12.png"></p><p>v2 版本的 pod 有两个已经就绪，同时正在启动最后一个新的 pod，与此同时 v1 版本的有两个 pod 已经关机了，而另外一个 pod 仍处于就绪状态。</p><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/13.png"> </p><p>v2 版本的 pod 已经全部处于就绪状态了，同时 v1 版本的 pod 已经全部关机，至此，一次滚动更新结束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 Kubernetes 原生方式实现滚动更新更加简单方便，但也容易出错（人工），推荐使用 <a href="https://coding.net/">coding.net</a> 提供的 CD 功能，配置一次，永久使用。不仅可以直观的观察到 pod 更新过程，还提供了非常丰富的 CD 功能，推荐使用哦~</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/update/update-intro/">Kuerbenetes</a></p><p><a href="https://help.coding.net/docs/cd/overview.html">CODING 持续部署</a></p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CODING </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> 服务发布 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
