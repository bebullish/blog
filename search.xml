<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kubernetes 优雅关闭</title>
      <link href="archives/fa802731.html"/>
      <url>archives/fa802731.html</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-优雅关闭"><a href="#Kubernetes-优雅关闭" class="headerlink" title="Kubernetes 优雅关闭"></a>Kubernetes 优雅关闭</h1><h2 id="删除-Pod-原理"><a href="#删除-Pod-原理" class="headerlink" title="删除 Pod 原理"></a>删除 Pod 原理</h2><p>kubernetes 删除 pod 的过程如下</p><p><img src="https://image-1300600292.cos.ap-guangzhou.myqcloud.com/uPic/2021/01/3a7OUu.png" alt="pod 删除过程"></p><p>pod 收到 delete 指令后，会同时做两件事</p><ul><li>修改 pod 状态，并将其准备关闭</li><li>删除 endpoint，使流量不再流入该 pod</li></ul><p>我们分别解释下上述五个动作会发生什么事情</p><ul><li>首先是绿色部分<ul><li>1：开启 terminationGracePeriodSeconds 计时，将 pod 状态置为 terminating，但实际上还没有关闭 pod</li><li>2：执行 preStop 钩子（如果有的话）</li><li>3：给容器发送<code>SIGTERM</code> 信号</li><li>4：如果在 terminationGracePeriodSeconds 的时间内还未结束，发送 <code>SIGKILL</code> 信号，强行关闭 pod</li></ul></li><li>青色部分<ul><li>A：删除 pod 对应的 endpoint，kube-proxy 检测到 endpoint 被删除，通知 Service 更新 endpoint，service 更新后，新的流量将不会流入到该 pod</li></ul></li></ul><blockquote><p><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination">更多的细节参考官方介绍</a></p></blockquote><h2 id="流量是如何打到-pod-上的"><a href="#流量是如何打到-pod-上的" class="headerlink" title="流量是如何打到 pod 上的"></a>流量是如何打到 pod 上的</h2><p><img src="https://image-1300600292.cos.ap-guangzhou.myqcloud.com/uPic/2021/01/gPszMF.png" alt="kubernetes kube-proxy"></p><h2 id="优雅关闭"><a href="#优雅关闭" class="headerlink" title="优雅关闭"></a>优雅关闭</h2><p>首先应用程序需要正确处理 <code>SIGTERM</code> 信号，先保证应用程序可以优雅关闭，其次，由于删除 pod 对应的 endpoint 是异步的，所以需要在 <code>preStop</code> 增加一个 <code>sleep</code> 指令，用来等待 endpoint 删除，例如：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">lifecycle</span><span class="token punctuation">:</span>  <span class="token key atrule">preStop</span><span class="token punctuation">:</span>    <span class="token key atrule">exec</span><span class="token punctuation">:</span>      <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"sleep"</span><span class="token punctuation">,</span> <span class="token string">"15"</span><span class="token punctuation">]</span></code></pre><blockquote><p>由于绿色任务链的所有任务所占用的时间都计算 <code>terminationGracePeriodSeconds</code> 耗时，所以 <code>terminationGracePeriodSeconds</code> 设置的值应为 <code>preStop</code> 执行时长 <code>+</code> 应用程序优雅关闭时长</p><p>由于在执行 <code>preStop</code> 命令的时候，pod 需要可以正常处理请求，所以 <code>preStop</code> 命令不能影响 pod 的正常工作，否则会有小部分请求异常</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Kubernetes 在考虑到生产就绪性方面已经做得很好了，但是为了在生产环境中运行我们的企业级应用，我们就必须了解 Kubernetes 是如何在后台运行的，以及我们的应用程序在启动和关闭期间的行为。而且上面的方式是只适用于短连接的，对于类似于 websocket 这种长连接应用需要做滚动更新的话目前还没有找到一个很好的解决方案，有的团队是将长连接转换成短连接来进行处理的，我这边还是在应用层面来做的支持，比如客户端增加重试机制，连接断掉以后会自动重新连接，大家如果有更好的办法也可以留言互相讨论下方案。</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> graceShutdown </tag>
            
            <tag> 优雅关闭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring WebFlux 入门系列（二）：Reactor</title>
      <link href="archives/6241198f.html"/>
      <url>archives/6241198f.html</url>
      
        <content type="html"><![CDATA[<h2 id="Reactor-简介"><a href="#Reactor-简介" class="headerlink" title="Reactor 简介"></a>Reactor 简介</h2><p><code>Reactor</code> 框架是 <code>Pivotal</code> 基于 <code>Reactive Programming</code> 思想实现的，它符合 <code>Reactive Streams</code> 规范。</p><h3 id="Reactive-Programming"><a href="#Reactive-Programming" class="headerlink" title="Reactive Programming"></a>Reactive Programming</h3><p>我们可以与<strong>迭代器模式</strong>做对比来了解反应式编程基本思想。表格中<code>Observable</code>便代表反应式编程的 API 的使用方式，它其实是<strong>观察者模式</strong>的一种延伸。如果将<strong>迭代器模式</strong>看作是<strong>拉模式</strong>，那<strong>观察者模式</strong>便是<strong>推模式</strong>。</p><table><thead><tr><th>事件</th><th>Iterable（pull）</th><th>Observable（push）</th></tr></thead><tbody><tr><td>获取数据</td><td>T next()</td><td>onNext(T)</td></tr><tr><td>发现异常</td><td>throws Exception</td><td>onError(Exception)</td></tr><tr><td>处理完成</td><td>hasNext()</td><td>onCompleted()</td></tr></tbody></table><blockquote><p><strong>被订阅者</strong><code>(Publisher)</code>主动推送数据给<strong>订阅者</strong><code>(Subscriber)</code>，触发 <code>onNext()</code> 方法。</p><p><strong>被订阅者</strong><code>(Publisher)</code>发生异常，则触发<strong>订阅者</strong><code>(Subscriber)</code>的 <code>onError()</code> 方法。</p><p><strong>被订阅者</strong><code>(Publisher)</code>每次推送都会触发一次 <code>onNext() </code>方法。所有的推送完成且无异常时，<code>onCompleted()</code>方法将<strong>在最后</strong>触发一次。</p></blockquote><p>如果 <code>Publisher</code> 发布消息太快了，超过了 <code>Subscriber</code> 的处理速度，那怎么办？这就是 <code>Backpressure</code> 的由来。<code>Reactive Programming</code> 框架需要提供<strong>背压机制</strong>，使得 <code>Subscriber</code> 能够控制<strong>消费消息</strong>的速度。</p><h3 id="Reactive-Streams"><a href="#Reactive-Streams" class="headerlink" title="Reactive Streams"></a>Reactive Streams</h3><p>在 Java 平台上，Netflix、TypeSaf、Pivatol 共同制定了一个被称为 <code>Reactive Streams</code> 项目（规范），用于制定反应式编程相关的规范以及接口。他们各自开发的框架如下：</p><ul><li>Netflix - RxJava</li><li>TypeSafe - Scala、Akka</li><li>Pivatol - Spring Reactor</li></ul><p><code>Reactive Streams</code> 由以下几个组件组成：</p><ul><li><strong>发布者</strong>：发布元素到订阅者</li><li><strong>订阅者</strong>：消费元素</li><li><strong>订阅</strong>：在发布者中，订阅被创建时，将与订阅者共享</li><li><strong>处理器</strong>：发布者与订阅者之间处理数据</li></ul><p>其主要的接口有这三个：</p><ul><li>Publisher</li><li>Subscriber</li><li>Subcription</li></ul><p>其中，<code>Subcriber</code> 中便包含了上面表格提到的 <code>onNext</code>、<code>onError</code>、<code>onCompleted</code> 这三个方法。对于 <code>Reactive Streams</code>，只需要理解其思想就可以，包括基本思想以及 <code>Backpressure</code> 等思想即可。</p><h3 id="Reactor-的主要模块"><a href="#Reactor-的主要模块" class="headerlink" title="Reactor 的主要模块"></a>Reactor 的主要模块</h3><p><code>Reactor</code> 框架主要有两个主要的模块：</p><ul><li>reactor-core - 负责 <code>Reactive Programming</code> 相关的核心 API 的实现</li><li>reactor-ipc - 负责<strong>高性能网络通信</strong>的实现，目前是基于 <code>Netty</code> 实现的。</li></ul><h3 id="Reactor-的核心类"><a href="#Reactor-的核心类" class="headerlink" title="Reactor 的核心类"></a>Reactor 的核心类</h3><ul><li><code>Mono</code> - 实现了 <code>org.reactivestreams.Publisher</code> 接口，代表 <code>0</code> 到 <code>1</code> 个元素的<strong>发布者</strong>。</li><li><code>Flux</code> - 实现了 <code>org.reactivestreams.Publisher</code> 接口，代表 <code>0</code> 到 <code>N</code> 个元素的<strong>发布者</strong>。</li><li><code>Scheduler</code> - 代表背后驱动反应式流的调度器，通常由各种线程池实现。</li></ul><h3 id="WebFlux"><a href="#WebFlux" class="headerlink" title="WebFlux"></a>WebFlux</h3><p><code>Spring 5</code> 引入的一个基于 <code>Netty</code> 而不是 <code>Servlet</code> 的高性能的 <code>Web</code> 框架 <code>Spring WebFlux</code>，但是使用方式并没有同传统的基于 <code>Servlet</code> 的 <code>Spring MVC</code> 有什么大的不同。</p><p><code>WebFlux</code> 中 <code>MVC</code> 接口的示例：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/webflux"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebFluxTestController</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/mono"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Mono<span class="token operator">&lt;</span>Foobar<span class="token operator">></span> <span class="token function">foobar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Mono<span class="token punctuation">.</span><span class="token function">just</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Foobar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="Reactive-Streams、Reactor-和-WebFlux"><a href="#Reactive-Streams、Reactor-和-WebFlux" class="headerlink" title="Reactive Streams、Reactor 和 WebFlux"></a>Reactive Streams、Reactor 和 WebFlux</h3><p>上面介绍了<strong>反应式编程</strong>的一些概念。可能读者看到这里有些乱，梳理一下三者的关系：</p><ol><li><code>Reactive Streams</code> 是一套反应式编程<strong>标准</strong>和<strong>规范</strong>；</li><li><code>Reactor</code> 符合 <code>Reactive Streams</code> 规范的<strong>反应式编程框架</strong>；</li><li><code>WebFlux</code> 以 <code>Reactor</code> 为基础，实现 <code>Web</code> 领域的<strong>反应式编程框架</strong>。</li></ol><p>其实，对于业务开发人员来说，当编写反应式代码时，通常只会接触到 <code>Publisher</code> 这个接口，对应到 <code>Reactor</code> 便是 <code>Mono</code> 和 <code>Flux</code>。</p><p>对于 <code>Subscriber</code> 和 <code>Subcription</code> 这两个接口，<code>Reactor</code> 也有相应的实现。这些都是 <code>Spring WebFlux</code> 和 <code>Spring Data Reactive</code> 这样的框架用到的。如果不开发<strong>中间件</strong>，开发人员是不会接触到的。</p><h2 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h2><p>还记得我们在 <a href="http://blog.bebullish.cn/archives/1b0037d2.html">Spring WebFlux 入门系列（一）：反应式编程</a> 这篇文章中实现的反应式编程的例子吗？这一次我们使用 Reactor API 将伪代码部分以 Java 语法重新实现。</p><p><em>代码示例-1</em></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">reactor1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 定义输入流，值固定为 1 和 3</span>  Flux<span class="token operator">&lt;</span>Integer<span class="token operator">></span> sourceFlux <span class="token operator">=</span> Flux<span class="token punctuation">.</span><span class="token function">just</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 定义目标流，值来源于 sourceFlux，并且将其值增加 5</span>  Flux<span class="token operator">&lt;</span>Integer<span class="token operator">></span> targetFlux <span class="token operator">=</span> Flux<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>sourceFlux<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>it <span class="token operator">-</span><span class="token operator">></span> it <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 订阅并输出目标流的每个值</span>  targetFlux<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 还可以简写为下面这种写法，同时也是推荐的写法</span><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">reactor2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Flux<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>Flux<span class="token punctuation">.</span><span class="token function">just</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>it <span class="token operator">-</span><span class="token operator">></span> it <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>这个例子中的 Flux 是 Reactor 的两种核心类型之一，另一个类型是 Mono。两者都实现了反应式流的 Publisher 接口。Flux 代表具有零个、一个或者多个（可能是无限个）数据项的管道。Mono 是一种特殊的反应式类型，针对数据项不超过一个的场景，它进行了优化。</p><blockquote><p>Reactor 与 RxJava（ReactiveX）的对比如果你熟悉 RxJava 或者 ReactiveX ，那么你可能认为 Mono 和 Flux 类似于 Observable 和 Single。事实上它们不仅在语义上大致相同，还共享了很多相同的操作符。虽然我们在系列教程中主要介绍 Reactor，但是 Reactor 和 RxJava 的类型可以互相转换，其实 Spring 也可以使用 RxJava 的类型。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 反应式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reactor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring WebFlux 入门系列（一）：反应式编程</title>
      <link href="archives/1b0037d2.html"/>
      <url>archives/1b0037d2.html</url>
      
        <content type="html"><![CDATA[<h2 id="命令式编程与声明式编程"><a href="#命令式编程与声明式编程" class="headerlink" title="命令式编程与声明式编程"></a>命令式编程与声明式编程</h2><p>在介绍反应式编程之前，我们先简单了解下<strong>命令式编程（Imperative Programming）</strong>与<strong>声明式编程（Declarative Programming）</strong>。我们现在写的代码大多都是命令式编程，也就是说一步一步告诉机器怎么做，而声明式编程是告诉程序我期望一个什么样的结果，而不关心具体是怎么实现的。</p><p><em>代码示例-1</em></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 命令式编程</span><span class="token keyword">boolean</span> contaion <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dataArr <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> data <span class="token operator">:</span> dataArr<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        contaion <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>contaion<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 声明式编程</span>contaion <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>dataArr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span>data <span class="token operator">-</span><span class="token operator">></span> ArrayUtils<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>contaion<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="什么是反应式编程？"><a href="#什么是反应式编程？" class="headerlink" title="什么是反应式编程？"></a>什么是反应式编程？</h2><p><strong>简单来说，反应式编程（Reactive Programming）就是面向数据流编程</strong>。鼠标点击或者键盘按下本质上就是事件流，你可以监听并处理这些事件。这其中有三个核心概念 <code>Publisher</code>、<code>Subscriber</code> 和 <code>Stream</code>，鼠标和键盘是 <code>Publisher</code>，监听事件的函数是 <code>Subscriber</code>，而点击或按下之后产生的事件即为 <code>Stream</code>，其实就是 <a href="https://en.wikipedia.org/wiki/Observer_pattern">Observer Design Pattern</a>。既然和观察者模式一样，那为什么要有反应式编程这个概念呢？我们留到后面介绍。</p><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p><strong>数据流（Stream）</strong> 就是一个按时间排序的事件序列，它可以发出三种信号，<strong>值（Value）</strong>信号、<strong>异常（Error）</strong>信号或<strong>完成（Completed）</strong>信号，在 <code>Spring WebFlux</code> 中，这些信号被扩展，增加了 <strong>请求（Request）</strong>信号、<strong>终止（Terminate）</strong>信号等。我们所要做的就是对需要处理的信号定义相应的事件处理函数。在此基础上，你还可以通过官方提供的组合、过滤和创建等函数去操作这些 Stream。几乎任何东西都可以称之为 Stream：用户输入、时间日期、变量等等。</p><h2 id="变化传递"><a href="#变化传递" class="headerlink" title="变化传递"></a>变化传递</h2><p>上面说到反应式编程模型和观察者模式很像，但又有上面不同呢？那就是<strong>变化传递（Propagation Of Change）</strong>了，在观察者模式中，订阅者收到事件并处理后，这个过程就结束了。但反应式编程不同，它可以将这一次事件处理结果进行传递，就好比流水线作业一样，每个作业总是以上一个作业的结果作为输入，将自身的输出作为下一个作业的输入，直到结束。下面给出了命令式与反应式编程在变量更改时所做出的反应。</p><p><em>代码示例-2</em></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 命令式编程</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> sum <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 反应式编程，这里给出伪代码</span>A <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>B <span class="token operator">:</span><span class="token operator">=</span> A <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 定义一种关系，这里是指 B 永远等于 A + 5</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// B = 6</span>A <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// A 改变</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// B = 8</span></code></pre><p>在命令式编程方式中，<code>sum = a + 5</code> 解释为将 <code>a</code> 的值加 <code>5</code> 再赋值给 <code>sum</code>，这个过程是一次性的，赋值之后 <code>sum</code> 和 <code>a</code> 就没关系了，也就是说 <code>a</code> 的改变是不会传递的。但在反应式编程中，这种变化是可以传递的。在 Excel 中，相信你已经见过不少类似的情况了。</p><h2 id="反应式编程"><a href="#反应式编程" class="headerlink" title="反应式编程"></a>反应式编程</h2><p>熟悉了上面的一些概念之后，我们给出反应式编程的正式概念，<strong>反应式编程是一种面向数据流和变化传递的声明式编程</strong>。这意味着可以在编程语言中很方便地表达静态（数组和列表等）或动态（事件发射器）的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。我们用一张图来更好的解释它。</p><blockquote><p>其最早是由微软提出并引入到 .NET 平台中，随后 ES6 也引入了类似的技术。在 Java 平台上，较早采用反应式编程技术的是 Netflix 公司开源的 RxJava 框架。Hystrix 就是以 RxJava 为基础开发的。</p></blockquote><p><img src="../static/202010/0.png"></p><p>如上图，要解释反应式编程可以将其拆开分析</p><ul><li>数据流：图中原型及方形图标</li><li>变化传递：从白色、灰色到红色，从圆型到方形</li><li>声明式编程：图中只给出“我要什么”，而并没有告诉其“我要你怎么做”。</li></ul><h3 id="反应式编程特点"><a href="#反应式编程特点" class="headerlink" title="反应式编程特点"></a>反应式编程特点</h3><p>聊完了反应式编程的概念，我们来聊聊反应式编程的特点。</p><h5 id="1-事件驱动"><a href="#1-事件驱动" class="headerlink" title="1. 事件驱动"></a>1. 事件驱动</h5><p>在一个<strong>事件驱动</strong>的应用程序中，组件之间的交互是通过松耦合的<strong>生产者</strong> <code>（Producer）</code>和<strong>消费者</strong><code>（Consumer）</code> 来实现的。这些事件是以<strong>异步</strong>和<strong>非阻塞</strong>的方式发送和接收的。</p><p><strong>事件驱动</strong>的系统依靠<strong>推模式</strong><code>（Push）</code>而不是<strong>拉模式</strong><code>（Pull）</code>，即<strong>生产者</strong>是在有消息时才推送数据给<strong>消费者</strong>，而不是通过一种浪费资源方式：让<strong>消费者</strong>不断地<strong>轮询</strong>或<strong>等待数据</strong>。</p><h5 id="2-实时响应"><a href="#2-实时响应" class="headerlink" title="2. 实时响应"></a>2. 实时响应</h5><p>程序发起执行以后，应该<strong>快速</strong>返回存储<strong>结果的上下文</strong>，把具体执行交给<strong>后台线程</strong>。待处理完成以后，异步地将<strong>真实返回值</strong>封装在此<strong>上下文</strong>中，而不是<strong>阻塞</strong>程序的执行。实时响应是通过<strong>异步</strong>编程实现的，例如：发起调用后，快速返回类似 <code>java8</code> 中 <code>CompletableFuture</code> 对象。</p><h5 id="3-弹性机制"><a href="#3-弹性机制" class="headerlink" title="3. 弹性机制"></a>3. 弹性机制</h5><p>事件驱动的<strong>松散耦合</strong>提供了组件在失败下，可以抓获<strong>完全隔离</strong>的上下文场景，作为<strong>消息封装</strong>，发送到下游组件。在具体编程时可以<strong>检查错误</strong> ，比如：是否接收到，接收的命令是否可执行等，并决定如何应对。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>所以，如果要掌握反应式编程，首先我们先要将编程思维从命令式过渡到声明式，其次，我们所关注的重点，也将从对象或过程转变为数据流和变化传递。当然，还有一个需要关注的点，那就是数据流的来源。数据的变化、走向和最终的结果我们是已知且定义好的，但数据应该由谁来发出呢？它又从哪来呢？我们将在下一篇文章介绍。</p>]]></content>
      
      
      <categories>
          
          <category> 反应式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring WebFlux </tag>
            
            <tag> Reactor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Kubernetes 实现蓝绿发布</title>
      <link href="archives/213ace22.html"/>
      <url>archives/213ace22.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>软件世界比以往任何时候都更快。为了保持竞争力，需要尽快推出新的软件版本，而不会中断活跃用户访问，影响用户体验。越来越多企业已将其应用迁移到 Kubernetes。</p><p>在 Kubernetes 中有几种不同的方式发布应用，所以为了让应用在升级期间依然平稳提供服务，选择一个正确的发布策略就非常重要了，本篇文章将讲解在 Kubernetes 使用蓝绿更新的方式更新镜像。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>蓝绿发布是版本 1 与版本 2 会同时存在，通过控制 Service 来决定使用具体哪一个版本，也称为红黑部署。蓝绿发布与滚动更新不同，版本 2 （<code>绿</code>） 与版本 1（<code>蓝</code>）一起部署，在测试新版本满足要求后，然后更新 Service 对象，通过替换 label selector 中的版本标签来将流量发送到新版本，更新过程如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/15.png"></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="使用-Kubernetes-原生方式升级应用"><a href="#使用-Kubernetes-原生方式升级应用" class="headerlink" title="使用 Kubernetes 原生方式升级应用"></a>使用 Kubernetes 原生方式升级应用</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>image</p><pre><code>bebullish/demo:v1bebullish/demo:v2</code></pre><p>deployment-v1</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> demo<span class="token punctuation">-</span>dp<span class="token punctuation">-</span>v1<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> demo      <span class="token key atrule">version</span><span class="token punctuation">:</span> v1  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> demo        <span class="token key atrule">version</span><span class="token punctuation">:</span> v1    <span class="token key atrule">spec</span><span class="token punctuation">:</span>       <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> demo        <span class="token key atrule">image</span><span class="token punctuation">:</span> bebullish/demo<span class="token punctuation">:</span>v1        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span></code></pre><p>deployment-v2</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> demo<span class="token punctuation">-</span>dp<span class="token punctuation">-</span>v2<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> demo      <span class="token key atrule">version</span><span class="token punctuation">:</span> v2  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> demo        <span class="token key atrule">version</span><span class="token punctuation">:</span> v2    <span class="token key atrule">spec</span><span class="token punctuation">:</span>       <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> demo        <span class="token key atrule">image</span><span class="token punctuation">:</span> bebullish/demo<span class="token punctuation">:</span>v2        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span></code></pre><p>service</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> demo<span class="token punctuation">-</span>service<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> demo    <span class="token key atrule">version</span><span class="token punctuation">:</span> v1                              <span class="token comment" spellcheck="true"># 通过更改 version 来控制流量走向</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> LoadBalancer  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP</code></pre><p>将上述  <code>deployment-v1</code> 以及 <code>service</code> 保存为 yaml 文件，使用 <code>kubectl apply -f</code> 命令创建 yaml 资源，等待创建成功后，使用 <code>kubectl get svc</code> 获取 EXTERNAL-IP。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>如果使用浏览器测试的话，你会发现每次调用都会返回同一个 pod 的名字，那是因为浏览器发出的请求包含 keepAlive，所以需要使用 curl 来保证每次发出的请求都是重新创建的。</p><pre class=" language-sh"><code class="language-sh">curl -X GET http://$&#123;EXTERNAL-IP&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/16.png"></p><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>将上述 <code>deployment-v2</code> 保存为 yaml 文件，使用 <code>kubectl apply -f</code> 命令创建 yaml 资源，切换流量之前先执行命令，以便查看镜像更新过程</p><pre class=" language-sh"><code class="language-sh">while true; do curl -X GET http://$&#123;EXTERNAL-IP&#125; ; done</code></pre><p>等待 <code>deployment-v2</code> 创建成功后，通过将 service 的 version 值改为 v2 来切换流量</p><pre class=" language-sh"><code class="language-sh">kubectl edit service demo-service</code></pre><h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/17.png"></p><h4 id="请求流量"><a href="#请求流量" class="headerlink" title="请求流量"></a>请求流量</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/18.png"></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>首先可以发现在更新过程中，程序保持一直可用的状态，v2 版本部署成功之后，所有请求还是 v1 版本，当流量切换后，立刻出现 v2 版本的日志，并且不会出现 v1 版本的日志，说明流量是一次性切换的，如果需要回滚只需要将流量切回 v1 版本即可。</p><h3 id="使用-CODING-CD-方式升级应用"><a href="#使用-CODING-CD-方式升级应用" class="headerlink" title="使用 CODING CD 方式升级应用"></a>使用 CODING CD 方式升级应用</h3><h4 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/19.png"></p><p>service</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> demo<span class="token punctuation">-</span>service<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">createBy</span><span class="token punctuation">:</span> demo<span class="token punctuation">-</span>service       <span class="token comment" spellcheck="true"># 这里填写的标签，会被添加到对应的 ReplicaSet 中</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> LoadBalancer  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP</code></pre><p>这里注意，service 创建之后应不会匹配到任何资源，即 endpoint 为空，而在后面执行部署流程时会为 ReplicaSet 添加 label <code>createBy: demo-service</code> ，从而决定流量走向。</p><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/20.png"></p><p>部署成功之后可以看到 <code>demo-service</code></p><h4 id="配置制品"><a href="#配置制品" class="headerlink" title="配置制品"></a>配置制品</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/21.png"></p><p>使用 docker 官方镜像需要以 <code>docker.io</code> 开头</p><h4 id="配置-yaml-及绑定制品"><a href="#配置-yaml-及绑定制品" class="headerlink" title="配置 yaml 及绑定制品"></a>配置 yaml 及绑定制品</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/22.png"></p><p>replicaSet</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ReplicaSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> demo<span class="token punctuation">-</span>rs<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> demo  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> demo    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> docker.io/bebullish/demo          <span class="token key atrule">name</span><span class="token punctuation">:</span> demo          <span class="token key atrule">ports</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span></code></pre><p>阶段中选择 <code>部署（Manifest）</code> ，输入上述 yaml 文件（目前发布策略选项仅支持 ReplicaSet），这里需要把镜像的版本删除掉，在需要绑定的制品选择之前配置的制品。这样配置之后，每次执行的时候版本是动态传入的。</p><h4 id="蓝绿（红黑）发布配置"><a href="#蓝绿（红黑）发布配置" class="headerlink" title="蓝绿（红黑）发布配置"></a>蓝绿（红黑）发布配置</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/23.png"></p><p>在下方勾选让 CODING 部署控制台管理入口流量，然后选择 <code>demo-service</code> 所在的命名空间（我这里是在 <code>marlon</code> 这个命名空间下），然后选择 <code>demo-service</code> ，策略选择 Red/Black（Blue/Green），保存即可。</p><h4 id="发布制品"><a href="#发布制品" class="headerlink" title="发布制品"></a>发布制品</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/24.png"></p><p>选择应用和部署流程，输入版本 v1。</p><h4 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/25.png"></p><p>等待一小段时间后，就可以在部署控制台中看到发布的资源了。</p><h4 id="更新镜像版本"><a href="#更新镜像版本" class="headerlink" title="更新镜像版本"></a>更新镜像版本</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/26.png"></p><p>再次执行发布，版本输入 v2。</p><h4 id="更新原理"><a href="#更新原理" class="headerlink" title="更新原理"></a>更新原理</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/27.png"></p><p>基于 CODING CD 的蓝绿发布和一般的蓝绿发布略有不同，一旦 v2 版本的 pod 处于就绪状态后，他就会立即获得流量，而当所有的 v2 版本的 pod 处于就绪状态后，会禁用 v1 版本的 pod，此时所有流量会打到 v2 版本上，从而完成更新。</p><blockquote><p>注意：基于 CODING CD 的蓝绿发布会出现 v1 版本和 v2 版本同时获得流量的情况，具体取决于 pod 的就绪探针，v2 版本的 pod 一旦就绪，那么它就会获得流量，所以需要合理设计就绪探针，尽量减少 v1 版本和 v2 版本同时存在的时间差。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 Kubernetes 原生方式实现蓝绿更新步骤较多，但也容易出错，推荐使用 <a href="https://coding.net/">coding.net</a> 提供的 CD 功能，配置一次，永久使用。不仅降低了人工成本，提高容错率，还提供了非常丰富的 CD 功能，推荐使用哦~</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://spinnaker.io/guides/user/kubernetes-v2/traffic-management/">TrafficManagement</a></p><p><a href="https://spinnaker.io/guides/user/kubernetes-v2/rollout-strategies/">RolloutStrategies</a></p><p><a href="https://help.coding.net/docs/cd/overview.html">CODING 持续部署</a></p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> CODING </tag>
            
            <tag> 服务发布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Kubernetes 实现滚动发布</title>
      <link href="archives/17e0ecae.html"/>
      <url>archives/17e0ecae.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>软件世界比以往任何时候都更快。为了保持竞争力，需要尽快推出新的软件版本，而不会中断活跃用户访问，影响用户体验。越来越多企业已将其应用迁移到 Kubernetes。</p><p>在 Kubernetes 中有几种不同的方式发布应用，所以为了让应用在升级期间依然平稳提供服务，选择一个正确的发布策略就非常重要了，本篇文章将讲解如何在 Kubernetes 使用滚动更新的方式更新镜像。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>策略定义为 RollingUpdate 的 Deployment。滚动更新通过逐个替换实例来逐步部署新版本的应用，直到所有实例都被替换完成为止，会有新版旧版同时存在的情况。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">4</span>  <span class="token key atrule">strategy</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> RollingUpdate    <span class="token key atrule">rollingUpdate</span><span class="token punctuation">:</span>      <span class="token key atrule">maxSurge</span><span class="token punctuation">:</span> <span class="token number">0                          </span><span class="token comment" spellcheck="true"># 决定了配置中期望的副本数之外，最多允许超出的 pod 实例的数量</span>      <span class="token key atrule">maxUnavailable</span><span class="token punctuation">:</span> %25            <span class="token comment" spellcheck="true"># 决定了在滚动升级期间，相对于期望副本数能够允许有多少 pod 实例处于不可用状态</span></code></pre><p>上述更新策略执行结果如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/1.png"></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="使用-Kubernetes-原生方式升级应用"><a href="#使用-Kubernetes-原生方式升级应用" class="headerlink" title="使用 Kubernetes 原生方式升级应用"></a>使用 Kubernetes 原生方式升级应用</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>image</p><pre><code>bebullish/demo:v1bebullish/demo:v2</code></pre><p>deployment</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> demo<span class="token punctuation">-</span>dp<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> demo  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">strategy</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> RollingUpdate    <span class="token key atrule">rollingUpdate</span><span class="token punctuation">:</span>      <span class="token key atrule">maxSurge</span><span class="token punctuation">:</span> 25%      <span class="token key atrule">maxUnavailable</span><span class="token punctuation">:</span> 25%  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> demo    <span class="token key atrule">spec</span><span class="token punctuation">:</span>       <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> demo        <span class="token key atrule">image</span><span class="token punctuation">:</span> bebullish/demo<span class="token punctuation">:</span>v1        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span></code></pre><p>service</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> demo<span class="token punctuation">-</span>service<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> demo  <span class="token key atrule">type</span><span class="token punctuation">:</span> LoadBalancer  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP</code></pre><p>将上述 <code>deployment</code> 以及 <code>service</code> 保存为 yaml 文件，使用 <code>kubectl apply -f</code> 命令创建 yaml 资源，等待创建成功后，使用 <code>kubectl get svc</code> 获取 EXTERNAL-IP。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>如果使用浏览器测试的话，你会发现每次调用都会返回同一个 pod 的名字，那是因为浏览器发出的请求包含 keepAlive，所以需要使用 curl 来保证每次发出的请求都是重新创建的。</p><pre class=" language-sh"><code class="language-sh">curl -X GET http://$&#123;EXTERNAL-IP&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/2.png"></p><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>升级之前先执行命令，以便查看镜像更新过程</p><pre class=" language-sh"><code class="language-sh">while true; do curl -X GET http://$&#123;EXTERNAL-IP&#125; ; done</code></pre><p>更新镜像</p><pre class=" language-sh"><code class="language-sh">kubectl set image deployment demo-dp demo=bebullish/demo:v2</code></pre><h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/3.png"></p><h4 id="请求流量"><a href="#请求流量" class="headerlink" title="请求流量"></a>请求流量</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/4.png"></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>首先可以发现在更新过程中，程序保持一直可用的状态，在出现了 v2 版本之后，还会出现 v1 版本的日志，说明在这个期间 v1 和 v2 版本是同时存在的，等到 v2 版本的 pod 全部处于就绪状态之后，可以看到所有的请求就都是 v2 版本的了。</p><h3 id="使用-CODING-CD-方式升级应用"><a href="#使用-CODING-CD-方式升级应用" class="headerlink" title="使用 CODING CD 方式升级应用"></a>使用 CODING CD 方式升级应用</h3><h4 id="配置制品"><a href="#配置制品" class="headerlink" title="配置制品"></a>配置制品</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/5.png"></p><p>使用 docker 官方镜像需要以 <code>docker.io</code> 开头</p><h4 id="配置-yaml-及绑定制品"><a href="#配置-yaml-及绑定制品" class="headerlink" title="配置 yaml 及绑定制品"></a>配置 yaml 及绑定制品</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/6.png"></p><p>deployment</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> demo<span class="token punctuation">-</span>dp<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> demo  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">strategy</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> RollingUpdate    <span class="token key atrule">rollingUpdate</span><span class="token punctuation">:</span>      <span class="token key atrule">maxSurge</span><span class="token punctuation">:</span> 25%      <span class="token key atrule">maxUnavailable</span><span class="token punctuation">:</span> 25%  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> demo    <span class="token key atrule">spec</span><span class="token punctuation">:</span>       <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> demo        <span class="token key atrule">image</span><span class="token punctuation">:</span> docker.io/bebullish/demo        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>        <span class="token key atrule">readinessProbe</span><span class="token punctuation">:</span>          <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /            <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>          <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">30           </span><span class="token comment" spellcheck="true"># 延迟 30 秒检测，以便更好的观察更新过程</span>          <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>        <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>          <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /            <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>          <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">30           </span><span class="token comment" spellcheck="true"># 延迟 30 秒检测，以便更好的观察更新过程</span>          <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>      <span class="token key atrule">terminationGracePeriodSeconds</span><span class="token punctuation">:</span> <span class="token number">1      </span><span class="token comment" spellcheck="true"># 处于 Terminating 状态多久后，强制杀死 pod</span></code></pre><p>阶段中选择 <code>部署（Manifest）</code> ，输入上述 yaml 文件（主要增加了就绪探针和存活探针），这里需要把镜像的版本删除掉，在需要绑定的制品选择之前配置的制品。这样配置之后，每次执行的时候版本是动态传入的。</p><h4 id="发布制品"><a href="#发布制品" class="headerlink" title="发布制品"></a>发布制品</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/7.png"></p><p>选择应用和部署流程，输入版本 v1。</p><h4 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/8.png"></p><p>等待一小段时间后，就可以在部署控制台中看到发布的资源了。</p><h4 id="更新镜像版本"><a href="#更新镜像版本" class="headerlink" title="更新镜像版本"></a>更新镜像版本</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/9.png"></p><p>再次执行发布，版本输入 v2。</p><h4 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h4><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/10.png"></p><p>可以看到此时 v2 版本的 pod 有一个正在启动，而 v1 版本的 pod 全部处于就绪状态。</p><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/11.png"></p><p>v2 版本的 pod 有一个已经就绪，同时正在启动另一个新的 pod，与此同时 v1 版本的有一个 pod 已经关机了，而另外两个 pod 仍处于就绪状态。</p><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/12.png"></p><p>v2 版本的 pod 有两个已经就绪，同时正在启动最后一个新的 pod，与此同时 v1 版本的有两个 pod 已经关机了，而另外一个 pod 仍处于就绪状态。</p><p><img src="https://cdn.jsdelivr.net/gh/bebullish/blog/static/20200628/13.png"> </p><p>v2 版本的 pod 已经全部处于就绪状态了，同时 v1 版本的 pod 已经全部关机，至此，一次滚动更新结束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 Kubernetes 原生方式实现滚动更新更加简单方便，但也容易出错（人工），推荐使用 <a href="https://coding.net/">coding.net</a> 提供的 CD 功能，配置一次，永久使用。不仅可以直观的观察到 pod 更新过程，还提供了非常丰富的 CD 功能，推荐使用哦~</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/update/update-intro/">Kuerbenetes</a></p><p><a href="https://help.coding.net/docs/cd/overview.html">CODING 持续部署</a></p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> CODING </tag>
            
            <tag> 服务发布 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
